bubble_sort:
	addiu $s0, $0, 0 #index of number being compared to (changes each Pass)
	addiu $s1, $0, 1 #index of number being compared on (changes each Pass)
	addiu $s4, $0, 0	
	j doPass
	nop
doPass: #input- $s4,
	beq $s1, $a1, passDone	#test if we are done
	nop
	addiu $t4, $0, 4 #start getting number
	mullo $t3, $t4, $s0
	addu $t2, $t3, $a0
	lw $s2, 0($t2)
	mullo $t3, $t4, $s1
	addu $t2, $t3, $a0
	lw $s3, 0($t2)
	slt $t0, $s3, $s2
	beq $t0, $0, dontSwap
	nop
		addiu $s4, $0, 1 #set swap register
		addiu $t4, $0, 4
		mullo $t3, $t4, $s1
		addu $t2, $t3, $a0
		sw $s2, 0($t2)
		mullo $t3, $t4, $s0
		addu $t2, $t3, $a0
		sw $s3, 0($t2)
	dontSwap:
	addiu $t0, $0, 1
	addu $s0, $s0, $t0
	addu $s1, $s1, $t0
	j doPass
	nop
passDone:
	bne $s4, $0, notDone #test if swap bit is low, if so then we are
	nop
		return 
	notDone:
	addiu $t0, $0, 1
	addu $s0, $t0, $s0 #increment main pass index
	j setupPass
	nop